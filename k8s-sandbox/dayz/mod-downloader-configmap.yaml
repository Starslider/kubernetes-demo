---
apiVersion: v1
kind: ConfigMap
metadata:
  name: dayz-mod-downloader
  namespace: dayz
data:
  generate-steam-guard-code.py: |
    #!/usr/bin/env python3
    """
    Generate Steam Guard code from shared secret.
    Implements Steam's TOTP algorithm for generating authentication codes.
    """
    import hmac
    import hashlib
    import base64
    import time
    import sys
    
    def generate_steam_guard_code(shared_secret):
        """
        Generate a Steam Guard code from a shared secret.
        
        Args:
            shared_secret: Base64-encoded shared secret string
            
        Returns:
            A 5-character Steam Guard code
        """
        try:
            # Decode the base64 shared secret
            secret = base64.b64decode(shared_secret)
            
            # Get current time in 30-second intervals
            timestamp = int(time.time())
            time_buffer = timestamp // 30
            
            # Convert to bytes (big-endian)
            time_buffer_bytes = time_buffer.to_bytes(8, byteorder='big')
            
            # Generate HMAC-SHA1
            hmac_digest = hmac.new(secret, time_buffer_bytes, hashlib.sha1).digest()
            
            # Steam uses a specific code generation algorithm
            # Extract the last 4 bits to determine the starting position
            start = hmac_digest[19] & 0x0F
            code_point = int.from_bytes(hmac_digest[start:start+4], byteorder='big') & 0x7FFFFFFF
            
            # Steam's character set
            chars = '23456789BCDFGHJKMNPQRTVWXY'
            code = ''
            
            # Generate 5-character code
            for _ in range(5):
                code += chars[code_point % len(chars)]
                code_point //= len(chars)
            
            return code
        except Exception as e:
            print(f"Error generating code: {e}", file=sys.stderr)
            sys.exit(1)
    
    if __name__ == '__main__':
        if len(sys.argv) != 2:
            print("Usage: generate-steam-guard-code.py <shared_secret>", file=sys.stderr)
            sys.exit(1)
        
        shared_secret = sys.argv[1]
        code = generate_steam_guard_code(shared_secret)
        print(code)
  download-mods.sh: |
    #!/bin/bash
    set -e
    
    echo "=== DayZ Mod Installation Script ==="
    echo "Following official Bohemia documentation"
    
    # Ensure Python script is executable
    if [ -f "/scripts/generate-steam-guard-code.py" ]; then
      chmod +x /scripts/generate-steam-guard-code.py 2>/dev/null || true
    fi
    
    # Try to install Python if not available (for containers that support it)
    if ! command -v python3 &> /dev/null && ! command -v python &> /dev/null; then
      echo "Python not found, attempting to install..."
      if command -v apt-get &> /dev/null; then
        apt-get update -qq >/dev/null 2>&1 && apt-get install -y -qq python3 >/dev/null 2>&1 || true
      elif command -v apk &> /dev/null; then
        apk add --no-cache python3 >/dev/null 2>&1 || true
      elif command -v yum &> /dev/null; then
        yum install -y -q python3 >/dev/null 2>&1 || true
      fi
    fi
    
    # Ensure keys directory exists
    mkdir -p /home/steam/dayz/keys
    chmod 755 /home/steam/dayz/keys 2>/dev/null || true
    
    # Parse MODS env var (semicolon-separated list of IDs)
    if [ -z "$MODS" ]; then
      echo "No mods specified, skipping mod installation"
      exit 0
    fi
    
    # SteamCMD downloads to steamapps/workshop by default
    WORKSHOP_DIR="/home/steam/dayz/steamapps/workshop"
    mkdir -p "$WORKSHOP_DIR"
    
    # Generate Steam Guard code once at the beginning (to avoid rate limits)
    STEAM_GUARD_CODE=""
    PYTHON_CMD=""  # Initialize for later use in retry logic
    
    # Priority 1: Generate from shared secret (recommended for automation)
    if [ -n "$STEAMGUARDSHAREDSECRET" ]; then
      echo "Generating Steam Guard code from shared secret..."
      echo "  DEBUG: STEAMGUARDSHAREDSECRET is set (length: ${#STEAMGUARDSHAREDSECRET})"
      
      # Check if Python is available
      if command -v python3 &> /dev/null || command -v python &> /dev/null; then
        PYTHON_CMD=$(command -v python3 2>/dev/null || command -v python 2>/dev/null)
        echo "  DEBUG: Python found at: $PYTHON_CMD"
        
        # Generate code using the Python script
        if [ -f "/scripts/generate-steam-guard-code.py" ]; then
          echo "  DEBUG: Python script found at /scripts/generate-steam-guard-code.py"
          # Don't suppress errors - we need to see what's happening
          STEAM_GUARD_CODE=$($PYTHON_CMD /scripts/generate-steam-guard-code.py "$STEAMGUARDSHAREDSECRET" 2>&1)
          PYTHON_EXIT=$?
          
          if [ $PYTHON_EXIT -eq 0 ] && [ -n "$STEAM_GUARD_CODE" ] && [ ${#STEAM_GUARD_CODE} -eq 5 ]; then
            echo "✅ Generated Steam Guard code from shared secret: $STEAM_GUARD_CODE"
          else
            echo "⚠️  Failed to generate code from shared secret (exit: $PYTHON_EXIT)"
            echo "  DEBUG: Output was: $STEAM_GUARD_CODE"
            STEAM_GUARD_CODE=""
          fi
        else
          echo "⚠️  Python script not found at /scripts/generate-steam-guard-code.py"
          echo "  DEBUG: Checking /scripts directory contents:"
          ls -la /scripts/ 2>&1 || true
        fi
      else
        echo "⚠️  Python not available in container"
        echo "  DEBUG: Checking for Python:"
        which python3 python 2>&1 || true
      fi
    else
      echo "⚠️  STEAMGUARDSHAREDSECRET environment variable is not set"
      echo "  DEBUG: Available environment variables containing STEAM:"
      env | grep -i steam || true
    fi
    
    # Priority 2: Use provided Steam Guard code (temporary solution)
    if [ -z "$STEAM_GUARD_CODE" ] && [ -n "$STEAMGUARD" ]; then
      echo "Using provided Steam Guard code for automated authentication..."
      STEAM_GUARD_CODE="$STEAMGUARD"
    fi
    
    # Add initial delay to avoid hitting rate limits on startup
    echo "Waiting 5 seconds before starting downloads to avoid rate limits..."
    sleep 5
    
    # Parse mods and prepare download list
    IFS=';' read -ra MOD_ARRAY <<< "$MODS"
    MOD_COUNT=${#MOD_ARRAY[@]}
    echo "Found $MOD_COUNT mod(s) to process"
    
    # Process each mod with delays to avoid rate limits
      MOD_INDEX=0
    for MOD_ID in "${MOD_ARRAY[@]}"; do
      # Remove @ prefix if present
      MOD_ID_CLEAN="${MOD_ID#@}"
      MOD_INDEX=$((MOD_INDEX + 1))
      
      echo ""
      echo "Processing mod $MOD_INDEX/$MOD_COUNT: $MOD_ID_CLEAN"
      
      # Add delay between mods to avoid rate limits (except for first mod)
      if [ $MOD_INDEX -gt 1 ]; then
        DELAY=$((5 + MOD_INDEX))  # Increasing delay: 6s, 7s, 8s, etc.
        echo "  Waiting ${DELAY}s before processing to avoid rate limits..."
        sleep $DELAY
      fi
      
      MOD_PATH="$WORKSHOP_DIR/content/221100/$MOD_ID_CLEAN"
      
      # Check if mod already exists
      if [ -d "$MOD_PATH" ]; then
        echo "  Mod already downloaded, checking for updates..."
      else
        echo "  Downloading from Steam Workshop..."
      fi
      
      # Always run SteamCMD with validate to check for updates
      # The validate flag ensures mods are up-to-date and verifies file integrity
      MAX_RETRIES=5
      RETRY_COUNT=0
      DOWNLOAD_SUCCESS=false
      
      while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$DOWNLOAD_SUCCESS" = false ]; do
        if [ $RETRY_COUNT -gt 0 ]; then
          # Exponential backoff for retries, with longer delays for rate limit errors
          BACKOFF_DELAY=$((10 * (2 ** RETRY_COUNT)))  # 20s, 40s, 80s, 160s
          echo "  Retry attempt $RETRY_COUNT of $MAX_RETRIES..."
          echo "  Waiting ${BACKOFF_DELAY} seconds before retry (exponential backoff)..."
          sleep $BACKOFF_DELAY
          
          # Regenerate Steam Guard code if using shared secret (codes expire every 30s)
          if [ -n "$STEAMGUARDSHAREDSECRET" ] && [ -n "$PYTHON_CMD" ] && [ -f "/scripts/generate-steam-guard-code.py" ]; then
            echo "  Regenerating Steam Guard code for retry..."
            STEAM_GUARD_CODE=$($PYTHON_CMD /scripts/generate-steam-guard-code.py "$STEAMGUARDSHAREDSECRET" 2>/dev/null)
          fi
        fi
        
        if [ -d "$MOD_PATH" ]; then
          echo "  Updating mod (this may take several minutes for large mods)..."
        else
          echo "  Starting download (this may take several minutes for large mods)..."
        fi
        
        # Use timeout command with 2 hours (7200 seconds) for very large downloads
        # SteamCMD will handle its own retries, but we wrap it to prevent premature termination
        # The validate flag checks for updates and verifies file integrity
        # Capture exit code properly despite pipe
        set +e  # Temporarily disable exit on error for this section
        
        # Build SteamCMD command with optional Steam Guard code
        STEAMCMD_CMD="+force_install_dir /home/steam/dayz"
        
        # Add Steam Guard code to command if we have one
        if [ -n "$STEAM_GUARD_CODE" ]; then
          echo "  DEBUG: Using Steam Guard code: $STEAM_GUARD_CODE"
          STEAMCMD_CMD="$STEAMCMD_CMD +set_steam_guard_code $STEAM_GUARD_CODE"
        else
          echo "  ⚠️  WARNING: No Steam Guard code available! SteamCMD will prompt for manual entry."
          echo "  DEBUG: STEAM_GUARD_CODE is empty"
        fi
        
        echo "  DEBUG: SteamCMD command: $STEAMCMD_CMD +login [REDACTED] [REDACTED] +workshop_download_item ..."
        STEAMCMD_CMD="$STEAMCMD_CMD +login $STEAMACCOUNT $STEAMPASSWORD"
        STEAMCMD_CMD="$STEAMCMD_CMD +workshop_download_item 221100 $MOD_ID_CLEAN validate"
        STEAMCMD_CMD="$STEAMCMD_CMD +quit"
        
        timeout 7200 steamcmd $STEAMCMD_CMD 2>&1 | tee /tmp/steamcmd_output.log
        STEAMCMD_EXIT=${PIPESTATUS[0]}
        set -e  # Re-enable exit on error
        
        # Check for rate limit errors in output
        RATE_LIMIT_ERROR=false
        if grep -qi "rate limit\|too many requests\|429\|RATE LIMIT" /tmp/steamcmd_output.log 2>/dev/null; then
          RATE_LIMIT_ERROR=true
          echo "  ⚠️  Rate limit detected in SteamCMD output"
        fi
        
        # Check if download/update was successful
        if [ $STEAMCMD_EXIT -eq 0 ] && [ "$RATE_LIMIT_ERROR" = false ]; then
          # Check if download was successful by verifying mod directory exists
          if [ -d "$MOD_PATH" ]; then
            DOWNLOAD_SUCCESS=true
            if [ $RETRY_COUNT -eq 0 ] && [ -d "$MOD_PATH" ] 2>/dev/null; then
              # Check if SteamCMD actually updated anything by looking at output
              if grep -q "Success" /tmp/steamcmd_output.log 2>/dev/null || \
                 grep -q "Update state" /tmp/steamcmd_output.log 2>/dev/null; then
                echo "  ✅ Mod updated/verified successfully"
              else
                echo "  ✅ Mod is up-to-date"
              fi
            else
              echo "  ✅ Download/update completed successfully"
            fi
          else
            echo "  ⚠️  SteamCMD completed but mod directory not found"
            echo "  Checking for partial download..."
            # Wait a bit and check again (SteamCMD might still be finalizing)
            sleep 5
            if [ -d "$MOD_PATH" ]; then
              DOWNLOAD_SUCCESS=true
              echo "  ✅ Mod directory found after delay"
            else
              echo "  Retrying download..."
              RETRY_COUNT=$((RETRY_COUNT + 1))
            fi
          fi
        else
          if [ "$RATE_LIMIT_ERROR" = true ]; then
            echo "  ⚠️  Rate limit exceeded! Waiting longer before retry..."
            # Extra long wait for rate limit errors
            RETRY_COUNT=$((RETRY_COUNT + 1))
          elif [ $STEAMCMD_EXIT -eq 124 ]; then
            echo "  ⚠️  Download/update timed out after 2 hours, retrying..."
            RETRY_COUNT=$((RETRY_COUNT + 1))
          else
            echo "  ⚠️  Download/update failed with exit code $STEAMCMD_EXIT, retrying..."
            RETRY_COUNT=$((RETRY_COUNT + 1))
          fi
        fi
      done
      
      if [ "$DOWNLOAD_SUCCESS" = false ]; then
        echo "  ❌ Download/update failed after $MAX_RETRIES attempts!"
        echo "  Last SteamCMD output:"
        tail -20 /tmp/steamcmd_output.log 2>/dev/null || true
        continue
      fi
      
      # Create symbolic link in server root WITHOUT @ prefix (official docs)
      # Symlinks must point to the actual path on the mounted volume
      LINK_PATH="/home/steam/dayz/$MOD_ID_CLEAN"
      
      if [ -L "$LINK_PATH" ]; then
        echo "  Symlink already exists"
      else
        echo "  Creating symlink: $LINK_PATH -> $MOD_PATH"
        ln -s "$MOD_PATH" "$LINK_PATH"
      fi
      
      # Copy mod keys to server keys directory BEFORE lowercase conversion
      # Look for keys in standard locations (Keys, keys directories)
      if [ -d "$MOD_PATH/Keys" ] || [ -d "$MOD_PATH/keys" ]; then
        echo "  Copying mod signing keys..."
        cp -f "$MOD_PATH"/[Kk]eys/*.bikey /home/steam/dayz/keys/ 2>/dev/null || true
      fi
      
      # Also search for any .bikey files in the mod directory and copy them
      # Some mods might have keys in non-standard locations
      find "$MOD_PATH" -name "*.bikey" -type f | while read -r KEY_FILE; do
        KEY_NAME=$(basename "$KEY_FILE")
        if [ ! -f "/home/steam/dayz/keys/$KEY_NAME" ]; then
          echo "  Found additional key file: $KEY_NAME"
          cp -f "$KEY_FILE" /home/steam/dayz/keys/ 2>/dev/null || true
        fi
      done
      
      # Verify keys were copied
      if [ -d "$MOD_PATH/Keys" ] || [ -d "$MOD_PATH/keys" ]; then
        KEY_COUNT=$(find "$MOD_PATH"/[Kk]eys -name "*.bikey" 2>/dev/null | wc -l)
        if [ "$KEY_COUNT" -gt 0 ]; then
          echo "  ✅ Copied $KEY_COUNT key file(s) to server keys directory"
        fi
      fi
      
      # Copy mission folders to mpmissions directory (required for custom maps)
      # Note: DeerIsle mission folder is handled by a separate init container
      MPMISSIONS_DIR="/home/steam/dayz/mpmissions"
      mkdir -p "$MPMISSIONS_DIR"
      
      # Look for mission folders in the mod directory (for mods that include missions)
      echo "  Searching for mission folders in mod..."
      
      # First, try to find folders with common mission names
      find "$MOD_PATH" -type d \( -name "empty.deerisle" -o -name "dayzOffline.deerisle" -o -name "*.deerisle" \) | while read -r MISSION_DIR; do
        MISSION_NAME=$(basename "$MISSION_DIR")
        TARGET_MISSION="$MPMISSIONS_DIR/$MISSION_NAME"
        if [ ! -d "$TARGET_MISSION" ]; then
          echo "  Found mission folder: $MISSION_NAME"
          echo "  Copying mission folder: $MISSION_NAME -> mpmissions/"
          cp -r "$MISSION_DIR" "$TARGET_MISSION"
        else
          echo "  Mission folder $MISSION_NAME already exists in mpmissions/"
        fi
      done
      
      # Also check for any folders that contain init.c or mission.c files
      find "$MOD_PATH" -type f \( -name "init.c" -o -name "mission.c" \) | while read -r MISSION_FILE; do
        MISSION_DIR=$(dirname "$MISSION_FILE")
        MISSION_NAME=$(basename "$MISSION_DIR")
        # Skip if it's in the root or already copied, and name looks like a mission
        if [ "$MISSION_DIR" != "$MOD_PATH" ] && [ ! -d "$MPMISSIONS_DIR/$MISSION_NAME" ]; then
          # Check if directory name looks like a mission (contains dot or starts with dayzOffline)
          if [[ "$MISSION_NAME" == *.* ]] || [[ "$MISSION_NAME" == dayzOffline* ]]; then
            echo "  Found mission folder by init.c: $MISSION_NAME"
            echo "  Copying mission folder: $MISSION_NAME -> mpmissions/"
            cp -r "$MISSION_DIR" "$MPMISSIONS_DIR/$MISSION_NAME"
          fi
        fi
      done
      
      # Lowercase all files in mod directory (Linux is case-sensitive)
      echo "  Converting filenames to lowercase..."
      find "$MOD_PATH" -depth -exec bash -c 'file="{}"; dir=$(dirname "$file"); base=$(basename "$file"); lower=$(echo "$base" | tr "[:upper:]" "[:lower:]"); [ "$base" != "$lower" ] && mv "$file" "$dir/$lower" 2>/dev/null || true' \;
      
      echo "  ✅ Mod $MOD_ID_CLEAN installed successfully"
    done
    
    # Fix permissions for mission folders (ensure steam user can write storage directories)
    echo ""
    echo "Fixing permissions for mission folders..."
    MPMISSIONS_DIR="/home/steam/dayz/mpmissions"
    if [ -d "$MPMISSIONS_DIR" ]; then
      # Use permissive permissions since chown may not work on all volume types
      find "$MPMISSIONS_DIR" -type d -exec chmod 777 {} \; 2>/dev/null || true
      find "$MPMISSIONS_DIR" -type f -exec chmod 666 {} \; 2>/dev/null || true
      # Ensure empty.deerisle has write permissions for storage
      if [ -d "$MPMISSIONS_DIR/empty.deerisle" ]; then
        chmod -R 777 "$MPMISSIONS_DIR/empty.deerisle" 2>/dev/null || true
        # Create storage directory structure if it doesn't exist
        mkdir -p "$MPMISSIONS_DIR/empty.deerisle/storage_1" 2>/dev/null || true
        chmod 777 "$MPMISSIONS_DIR/empty.deerisle/storage_1" 2>/dev/null || true
        # Also create additional storage directories that might be needed
        for i in {1..10}; do
          mkdir -p "$MPMISSIONS_DIR/empty.deerisle/storage_$i" 2>/dev/null || true
          chmod 777 "$MPMISSIONS_DIR/empty.deerisle/storage_$i" 2>/dev/null || true
        done
      fi
    fi
    
    echo ""
    echo "=== Mod Installation Complete ==="
    echo "Installed mods will be loaded with: -mod=$MODS"
