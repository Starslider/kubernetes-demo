---
apiVersion: v1
kind: ConfigMap
metadata:
  name: dayz-mod-downloader
  namespace: dayz
data:
  download-mods.sh: |
    #!/bin/bash
    set -e
    
    echo "=== DayZ Mod Installation Script ==="
    echo "Following official Bohemia documentation"
    
    # Ensure keys directory exists
    mkdir -p /home/steam/dayz/keys
    chmod 755 /home/steam/dayz/keys 2>/dev/null || true
    
    # Parse MODS env var (semicolon-separated list of IDs)
    if [ -z "$MODS" ]; then
      echo "No mods specified, skipping mod installation"
      exit 0
    fi
    
    # SteamCMD downloads to steamapps/workshop by default
    WORKSHOP_DIR="/home/steam/dayz/steamapps/workshop"
    mkdir -p "$WORKSHOP_DIR"
    
    # Generate Steam Guard code once at the beginning (to avoid rate limits)
    STEAM_GUARD_CODE=""
    
    # Function to generate Steam Guard code using bash/openssl
    generate_steam_guard_code_bash() {
      local shared_secret="$1"
      local chars="23456789BCDFGHJKMNPQRTVWXY"
      
      # Decode base64 shared secret to binary
      local secret_bin
      if command -v base64 &> /dev/null; then
        secret_bin=$(echo -n "$shared_secret" | base64 -d 2>/dev/null)
      elif command -v openssl &> /dev/null; then
        secret_bin=$(echo -n "$shared_secret" | openssl base64 -d -A 2>/dev/null)
      else
        echo "ERROR: Neither base64 nor openssl available" >&2
        return 1
      fi
      
      if [ -z "$secret_bin" ]; then
        echo "ERROR: Failed to decode shared secret" >&2
        return 1
      fi
      
      # Get current time in 30-second intervals
      local timestamp=$(date +%s)
      local time_buffer=$((timestamp / 30))
      
      # Convert time_buffer to 8-byte big-endian hex string (more reliable than binary)
      local time_hex=""
      for i in {7..0}; do
        local byte=$((time_buffer >> (i * 8) & 0xFF))
        time_hex=$(printf "%s%02x" "$time_hex" "$byte")
      done
      
      # Convert secret to hex as well
      local secret_hex=$(printf "%s" "$secret_bin" | od -An -tx1 | tr -d ' \n')
      
      # Compute HMAC-SHA1 using openssl with hex-encoded key and data
      # Note: openssl -mac HMAC -macopt hexkey:KEY format (no quotes around KEY)
      local hmac_result
      if command -v openssl &> /dev/null; then
        # Method 1: Use xxd to convert hex to binary, then HMAC with hex key (no quotes in hexkey)
        if command -v xxd &> /dev/null; then
          hmac_result=$(printf "%s" "$time_hex" | xxd -r -p 2>/dev/null | openssl dgst -sha1 -mac HMAC -macopt "hexkey:$secret_hex" -binary 2>/dev/null | od -An -tx1 2>/dev/null | tr -d ' \n')
        fi
        
        # Method 2: If xxd not available or method 1 failed, use printf with hex escapes
        if [ -z "$hmac_result" ] || [ ${#hmac_result} -lt 40 ]; then
          # Build printf format string from hex
          local time_printf=$(echo "$time_hex" | sed 's/\(..\)/\\x\1/g')
          hmac_result=$(printf "$time_printf" 2>/dev/null | openssl dgst -sha1 -mac HMAC -macopt "hexkey:$secret_hex" -binary 2>/dev/null | od -An -tx1 2>/dev/null | tr -d ' \n')
        fi
        
        # Method 3: Fallback - use direct binary method (may not work with null bytes)
        if [ -z "$hmac_result" ] || [ ${#hmac_result} -lt 40 ]; then
          # Reconstruct time_bin from hex for direct binary method
          local time_bin=""
          for i in {0..7}; do
            local byte_hex="${time_hex:$((i * 2)):2}"
            local byte=$((0x$byte_hex))
            # Build binary string byte by byte
            if [ $byte -eq 0 ]; then
              # Handle null byte specially
              time_bin="${time_bin}$(printf '\0')"
            else
              time_bin="${time_bin}$(printf "\\$(printf "%03o" "$byte")" 2>/dev/null)"
            fi
          done
          # Try direct binary HMAC (may fail if secret_bin has null bytes)
          hmac_result=$(printf "%s" "$time_bin" | openssl dgst -sha1 -hmac "$secret_bin" -binary 2>/dev/null | od -An -tx1 2>/dev/null | tr -d ' \n')
        fi
      else
        echo "ERROR: openssl not available" >&2
        return 1
      fi
      
      if [ -z "$hmac_result" ] || [ ${#hmac_result} -lt 40 ]; then
        echo "ERROR: HMAC computation failed" >&2
        return 1
      fi
      
      # Extract last 4 bits to determine start position (from byte 19, which is index 38-39 in hex)
      local last_byte_hex="${hmac_result:38:2}"
      local start=$((0x$last_byte_hex & 0x0F))
      
      # Extract 4 bytes starting at position 'start' (each byte is 2 hex chars)
      local code_bytes_hex="${hmac_result:$((start * 2)):8}"
      local code_point=$((0x$code_bytes_hex & 0x7FFFFFFF))
      
      # Generate 5-character code using Steam's character set
      # Note: Append characters (not prepend) to match Steam's algorithm
      local code=""
      local temp_point=$code_point
      for i in {1..5}; do
        local idx=$((temp_point % ${#chars}))
        code="$code${chars:$idx:1}"
        temp_point=$((temp_point / ${#chars}))
      done
      
      # Output only the code to stdout, any errors go to stderr
      printf "%s\n" "$code" 2>/dev/null
    }
    
    # Generate Steam Guard code from shared secret (recommended for automation)
    if [ -n "$STEAMGUARDSHAREDSECRET" ]; then
      echo "Generating Steam Guard code from shared secret..."
      echo "  DEBUG: STEAMGUARDSHAREDSECRET is set (length: ${#STEAMGUARDSHAREDSECRET})"
      
      # Generate code using bash/openssl
      echo "  DEBUG: Generating code using bash/openssl"
      if command -v openssl &> /dev/null; then
        # Use a temp file to avoid command substitution null byte warnings
        temp_file=$(mktemp)
        generate_steam_guard_code_bash "$STEAMGUARDSHAREDSECRET" > "$temp_file" 2>/dev/null
        bash_output=$(cat "$temp_file" 2>/dev/null)
        rm -f "$temp_file" 2>/dev/null
        
        # Extract only the 5-character code - Steam codes are exactly 5 uppercase alphanumeric
        # Try multiple extraction methods
        STEAM_GUARD_CODE=$(echo "$bash_output" | grep -oE '[A-Z0-9]{5}' | head -1)
        
        # If that didn't work, try getting the last line and checking if it's 5 chars
        if [ -z "$STEAM_GUARD_CODE" ] || [ ${#STEAM_GUARD_CODE} -ne 5 ]; then
          last_line=$(echo "$bash_output" | tail -1 | tr -d '\n\r\t ')
          if [ ${#last_line} -eq 5 ] && [[ "$last_line" =~ ^[A-Z0-9]{5}$ ]]; then
            STEAM_GUARD_CODE="$last_line"
          fi
        fi
        
        # Final check - if still empty, try to extract any 5-char sequence
        if [ -z "$STEAM_GUARD_CODE" ] || [ ${#STEAM_GUARD_CODE} -ne 5 ]; then
          # Remove all non-alphanumeric, then take first 5 chars if it matches pattern
          cleaned=$(echo "$bash_output" | tr -cd 'A-Z0-9')
          if [ ${#cleaned} -ge 5 ]; then
            STEAM_GUARD_CODE="${cleaned:0:5}"
          fi
        fi
        
        # Validate the generated code
        if [ -n "$STEAM_GUARD_CODE" ] && [ ${#STEAM_GUARD_CODE} -eq 5 ] && [[ "$STEAM_GUARD_CODE" =~ ^[A-Z0-9]{5}$ ]]; then
          echo "✅ Generated Steam Guard code from shared secret (bash/openssl): $STEAM_GUARD_CODE"
        else
          echo "⚠️  Bash/openssl method failed to generate valid code"
          echo "  DEBUG: Raw output: '$bash_output'"
          echo "  DEBUG: Extracted: '$STEAM_GUARD_CODE' (length: ${#STEAM_GUARD_CODE})"
          STEAM_GUARD_CODE=""
        fi
      else
        echo "⚠️  openssl not available for code generation"
      fi
    else
      echo "⚠️  STEAMGUARDSHAREDSECRET environment variable is not set"
      echo "  DEBUG: Available environment variables containing STEAM:"
      env | grep -i steam || true
      echo "  ERROR: Steam Guard shared secret is required for automated authentication"
      exit 1
    fi
    
    # Verify we have a valid code before proceeding
    if [ -z "$STEAM_GUARD_CODE" ] || [ ${#STEAM_GUARD_CODE} -ne 5 ]; then
      echo "  ERROR: Failed to generate Steam Guard code from shared secret"
      exit 1
    fi
    
    # Add initial delay to avoid hitting rate limits on startup
    echo "Waiting 5 seconds before starting downloads to avoid rate limits..."
    sleep 5
    
    # Parse mods and prepare download list
    IFS=';' read -ra MOD_ARRAY <<< "$MODS"
    MOD_COUNT=${#MOD_ARRAY[@]}
    echo "Found $MOD_COUNT mod(s) to process"
    
    # Process each mod with delays to avoid rate limits
      MOD_INDEX=0
    for MOD_ID in "${MOD_ARRAY[@]}"; do
      # Remove @ prefix if present
      MOD_ID_CLEAN="${MOD_ID#@}"
      MOD_INDEX=$((MOD_INDEX + 1))
      
      echo ""
      echo "Processing mod $MOD_INDEX/$MOD_COUNT: $MOD_ID_CLEAN"
      
      # Add delay between mods to avoid rate limits (except for first mod)
      if [ $MOD_INDEX -gt 1 ]; then
        DELAY=$((5 + MOD_INDEX))  # Increasing delay: 6s, 7s, 8s, etc.
        echo "  Waiting ${DELAY}s before processing to avoid rate limits..."
        sleep $DELAY
      fi
      
      MOD_PATH="$WORKSHOP_DIR/content/221100/$MOD_ID_CLEAN"
      
      # Check if mod already exists
      if [ -d "$MOD_PATH" ]; then
        echo "  Mod already downloaded, checking for updates..."
      else
        echo "  Downloading from Steam Workshop..."
      fi
      
      # Always run SteamCMD with validate to check for updates
      # The validate flag ensures mods are up-to-date and verifies file integrity
      MAX_RETRIES=5
      RETRY_COUNT=0
      DOWNLOAD_SUCCESS=false
      
      while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$DOWNLOAD_SUCCESS" = false ]; do
        if [ $RETRY_COUNT -gt 0 ]; then
          # Exponential backoff for retries, with longer delays for rate limit errors
          BACKOFF_DELAY=$((10 * (2 ** RETRY_COUNT)))  # 20s, 40s, 80s, 160s
          echo "  Retry attempt $RETRY_COUNT of $MAX_RETRIES..."
          echo "  Waiting ${BACKOFF_DELAY} seconds before retry (exponential backoff)..."
          sleep $BACKOFF_DELAY
          
          # Regenerate Steam Guard code if using shared secret (codes expire every 30s)
          if [ -n "$STEAMGUARDSHAREDSECRET" ] && command -v openssl &> /dev/null; then
            echo "  Regenerating Steam Guard code for retry..."
            temp_file=$(mktemp)
            generate_steam_guard_code_bash "$STEAMGUARDSHAREDSECRET" > "$temp_file" 2>/dev/null
            bash_output=$(cat "$temp_file" 2>/dev/null)
            rm -f "$temp_file" 2>/dev/null
            STEAM_GUARD_CODE=$(echo "$bash_output" | grep -oE '[A-Z0-9]{5}' | head -1)
            if [ -z "$STEAM_GUARD_CODE" ] || [ ${#STEAM_GUARD_CODE} -ne 5 ]; then
              last_line=$(echo "$bash_output" | tail -1 | tr -d '\n\r\t ')
              if [ ${#last_line} -eq 5 ] && [[ "$last_line" =~ ^[A-Z0-9]{5}$ ]]; then
                STEAM_GUARD_CODE="$last_line"
              fi
            fi
          fi
        fi
        
        if [ -d "$MOD_PATH" ]; then
          echo "  Updating mod (this may take several minutes for large mods)..."
        else
          echo "  Starting download (this may take several minutes for large mods)..."
        fi
        
        # Use timeout command with 2 hours (7200 seconds) for very large downloads
        # SteamCMD will handle its own retries, but we wrap it to prevent premature termination
        # The validate flag checks for updates and verifies file integrity
        # Capture exit code properly despite pipe
        set +e  # Temporarily disable exit on error for this section
        
        # Build SteamCMD command with optional Steam Guard code
        STEAMCMD_CMD="+force_install_dir /home/steam/dayz"
        
        # Add Steam Guard code to command if we have one
        if [ -n "$STEAM_GUARD_CODE" ]; then
          echo "  DEBUG: Using Steam Guard code: $STEAM_GUARD_CODE"
          STEAMCMD_CMD="$STEAMCMD_CMD +set_steam_guard_code $STEAM_GUARD_CODE"
        else
          echo "  ⚠️  WARNING: No Steam Guard code available! SteamCMD will prompt for manual entry."
          echo "  DEBUG: STEAM_GUARD_CODE is empty"
        fi
        
        echo "  DEBUG: SteamCMD command: $STEAMCMD_CMD +login [REDACTED] [REDACTED] +workshop_download_item ..."
        STEAMCMD_CMD="$STEAMCMD_CMD +login $STEAMACCOUNT $STEAMPASSWORD"
        STEAMCMD_CMD="$STEAMCMD_CMD +workshop_download_item 221100 $MOD_ID_CLEAN validate"
        STEAMCMD_CMD="$STEAMCMD_CMD +quit"
        
        timeout 7200 steamcmd $STEAMCMD_CMD 2>&1 | tee /tmp/steamcmd_output.log
        STEAMCMD_EXIT=${PIPESTATUS[0]}
        set -e  # Re-enable exit on error
        
        # Check for rate limit errors in output
        RATE_LIMIT_ERROR=false
        if grep -qi "rate limit\|too many requests\|429\|RATE LIMIT" /tmp/steamcmd_output.log 2>/dev/null; then
          RATE_LIMIT_ERROR=true
          echo "  ⚠️  Rate limit detected in SteamCMD output"
        fi
        
        # Check if download/update was successful
        if [ $STEAMCMD_EXIT -eq 0 ] && [ "$RATE_LIMIT_ERROR" = false ]; then
          # Check if download was successful by verifying mod directory exists
          if [ -d "$MOD_PATH" ]; then
            DOWNLOAD_SUCCESS=true
            if [ $RETRY_COUNT -eq 0 ] && [ -d "$MOD_PATH" ] 2>/dev/null; then
              # Check if SteamCMD actually updated anything by looking at output
              if grep -q "Success" /tmp/steamcmd_output.log 2>/dev/null || \
                 grep -q "Update state" /tmp/steamcmd_output.log 2>/dev/null; then
                echo "  ✅ Mod updated/verified successfully"
              else
                echo "  ✅ Mod is up-to-date"
              fi
            else
              echo "  ✅ Download/update completed successfully"
            fi
          else
            echo "  ⚠️  SteamCMD completed but mod directory not found"
            echo "  Checking for partial download..."
            # Wait a bit and check again (SteamCMD might still be finalizing)
            sleep 5
            if [ -d "$MOD_PATH" ]; then
              DOWNLOAD_SUCCESS=true
              echo "  ✅ Mod directory found after delay"
            else
              echo "  Retrying download..."
              RETRY_COUNT=$((RETRY_COUNT + 1))
            fi
          fi
        else
          if [ "$RATE_LIMIT_ERROR" = true ]; then
            echo "  ⚠️  Rate limit exceeded! Waiting longer before retry..."
            # Extra long wait for rate limit errors
            RETRY_COUNT=$((RETRY_COUNT + 1))
          elif [ $STEAMCMD_EXIT -eq 124 ]; then
            echo "  ⚠️  Download/update timed out after 2 hours, retrying..."
            RETRY_COUNT=$((RETRY_COUNT + 1))
          else
            echo "  ⚠️  Download/update failed with exit code $STEAMCMD_EXIT, retrying..."
            RETRY_COUNT=$((RETRY_COUNT + 1))
          fi
        fi
      done
      
      if [ "$DOWNLOAD_SUCCESS" = false ]; then
        echo "  ❌ Download/update failed after $MAX_RETRIES attempts!"
        echo "  Last SteamCMD output:"
        tail -20 /tmp/steamcmd_output.log 2>/dev/null || true
        continue
      fi
      
      # Create symbolic link in server root WITHOUT @ prefix (official docs)
      # Symlinks must point to the actual path on the mounted volume
      LINK_PATH="/home/steam/dayz/$MOD_ID_CLEAN"
      
      if [ -L "$LINK_PATH" ]; then
        echo "  Symlink already exists"
      else
        echo "  Creating symlink: $LINK_PATH -> $MOD_PATH"
        ln -s "$MOD_PATH" "$LINK_PATH"
      fi
      
      # Copy mod keys to server keys directory BEFORE lowercase conversion
      # Look for keys in standard locations (Keys, keys directories)
      if [ -d "$MOD_PATH/Keys" ] || [ -d "$MOD_PATH/keys" ]; then
        echo "  Copying mod signing keys..."
        cp -f "$MOD_PATH"/[Kk]eys/*.bikey /home/steam/dayz/keys/ 2>/dev/null || true
      fi
      
      # Also search for any .bikey files in the mod directory and copy them
      # Some mods might have keys in non-standard locations
      find "$MOD_PATH" -name "*.bikey" -type f | while read -r KEY_FILE; do
        KEY_NAME=$(basename "$KEY_FILE")
        if [ ! -f "/home/steam/dayz/keys/$KEY_NAME" ]; then
          echo "  Found additional key file: $KEY_NAME"
          cp -f "$KEY_FILE" /home/steam/dayz/keys/ 2>/dev/null || true
        fi
      done
      
      # Verify keys were copied
      if [ -d "$MOD_PATH/Keys" ] || [ -d "$MOD_PATH/keys" ]; then
        KEY_COUNT=$(find "$MOD_PATH"/[Kk]eys -name "*.bikey" 2>/dev/null | wc -l)
        if [ "$KEY_COUNT" -gt 0 ]; then
          echo "  ✅ Copied $KEY_COUNT key file(s) to server keys directory"
        fi
      fi
      
      # Copy mission folders to mpmissions directory (required for custom maps)
      # Note: DeerIsle mission folder is handled by a separate init container
      MPMISSIONS_DIR="/home/steam/dayz/mpmissions"
      mkdir -p "$MPMISSIONS_DIR"
      
      # Look for mission folders in the mod directory (for mods that include missions)
      echo "  Searching for mission folders in mod..."
      
      # First, try to find folders with common mission names
      find "$MOD_PATH" -type d \( -name "empty.deerisle" -o -name "dayzOffline.deerisle" -o -name "*.deerisle" \) | while read -r MISSION_DIR; do
        MISSION_NAME=$(basename "$MISSION_DIR")
        TARGET_MISSION="$MPMISSIONS_DIR/$MISSION_NAME"
        if [ ! -d "$TARGET_MISSION" ]; then
          echo "  Found mission folder: $MISSION_NAME"
          echo "  Copying mission folder: $MISSION_NAME -> mpmissions/"
          cp -r "$MISSION_DIR" "$TARGET_MISSION"
        else
          echo "  Mission folder $MISSION_NAME already exists in mpmissions/"
        fi
      done
      
      # Also check for any folders that contain init.c or mission.c files
      find "$MOD_PATH" -type f \( -name "init.c" -o -name "mission.c" \) | while read -r MISSION_FILE; do
        MISSION_DIR=$(dirname "$MISSION_FILE")
        MISSION_NAME=$(basename "$MISSION_DIR")
        # Skip if it's in the root or already copied, and name looks like a mission
        if [ "$MISSION_DIR" != "$MOD_PATH" ] && [ ! -d "$MPMISSIONS_DIR/$MISSION_NAME" ]; then
          # Check if directory name looks like a mission (contains dot or starts with dayzOffline)
          if [[ "$MISSION_NAME" == *.* ]] || [[ "$MISSION_NAME" == dayzOffline* ]]; then
            echo "  Found mission folder by init.c: $MISSION_NAME"
            echo "  Copying mission folder: $MISSION_NAME -> mpmissions/"
            cp -r "$MISSION_DIR" "$MPMISSIONS_DIR/$MISSION_NAME"
          fi
        fi
      done
      
      # Lowercase all files in mod directory (Linux is case-sensitive)
      echo "  Converting filenames to lowercase..."
      find "$MOD_PATH" -depth -exec bash -c 'file="{}"; dir=$(dirname "$file"); base=$(basename "$file"); lower=$(echo "$base" | tr "[:upper:]" "[:lower:]"); [ "$base" != "$lower" ] && mv "$file" "$dir/$lower" 2>/dev/null || true' \;
      
      echo "  ✅ Mod $MOD_ID_CLEAN installed successfully"
    done
    
    # Fix permissions for mission folders (ensure steam user can write storage directories)
    echo ""
    echo "Fixing permissions for mission folders..."
    MPMISSIONS_DIR="/home/steam/dayz/mpmissions"
    if [ -d "$MPMISSIONS_DIR" ]; then
      # Use permissive permissions since chown may not work on all volume types
      find "$MPMISSIONS_DIR" -type d -exec chmod 777 {} \; 2>/dev/null || true
      find "$MPMISSIONS_DIR" -type f -exec chmod 666 {} \; 2>/dev/null || true
      # Ensure empty.deerisle has write permissions for storage
      if [ -d "$MPMISSIONS_DIR/empty.deerisle" ]; then
        chmod -R 777 "$MPMISSIONS_DIR/empty.deerisle" 2>/dev/null || true
        # Create storage directory structure if it doesn't exist
        mkdir -p "$MPMISSIONS_DIR/empty.deerisle/storage_1" 2>/dev/null || true
        chmod 777 "$MPMISSIONS_DIR/empty.deerisle/storage_1" 2>/dev/null || true
        # Also create additional storage directories that might be needed
        for i in {1..10}; do
          mkdir -p "$MPMISSIONS_DIR/empty.deerisle/storage_$i" 2>/dev/null || true
          chmod 777 "$MPMISSIONS_DIR/empty.deerisle/storage_$i" 2>/dev/null || true
        done
      fi
    fi
    
    echo ""
    echo "=== Mod Installation Complete ==="
    echo "Installed mods will be loaded with: -mod=$MODS"
